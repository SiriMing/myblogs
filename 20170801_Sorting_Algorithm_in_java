/*今天是建军节，每年这个时候总是想起一些硬汉。未来的日子里，我也会遇到一些挑战，希望可以在这些挑战中更好的向前进。

无意中和朋友们聊起了一些本科时期学习的数据结构知识。话说真的已经忘记了很多，但是今天找了找时间试图把这些学过的排序算法捡起来。现在汇总在下面。thanks黄向文老师曾经的讲授。

排序算法的目的是将一系列数据按照一定的格式，经过一定的算法运算后，转化为有特定序列的数据的过程。
*/

<strong><strong>目前常见的排序算法（其实是我目前能想起来的）有：</strong></strong>
<ul>
	<li><strong><strong>冒泡排序；</strong></strong></li>
	<li><strong><strong>快速排序（改进的冒泡排序）;</strong></strong></li>
	<li><strong><strong>选择排序；</strong></strong></li>
	<li><strong><strong>堆排序（改进的选择排序）;</strong></strong></li>
	<li><strong><strong>插入排序；</strong></strong></li>
	<li><strong><strong>希尔排序（改进的插入排序）;</strong></strong></li>
</ul>
&nbsp;

&nbsp;

下面对上述的排序算法进行一下简单汇总。

<strong>（1）冒泡排序；</strong>
<ul>
	<li>冒泡排序就是从左到右，亮亮对比，如果次序不符合要求就交换位置；</li>
	<li>这样遍历第一次后，则最右边的值极为符合要求的最值；</li>
	<li>继续遍历，即可完成排序。</li>
</ul>
public static void bubbleSort(int arr[])
{
for(int i=0;i&lt;arr.length-1;i++)
{
for(int j=0;j&lt;arr.length-i-1;j++)
{
if (arr[j]&lt;arr[j+1])
{
int temp=arr[j];
arr[j]=arr[j+1];
arr[j+1]=temp;
}
}
}

<strong>（2）快速排序；</strong>
<ul>
	<li>快速排序的关键在于分区交换排序，首先选择一个轴值；</li>
	<li>该轴值的选择需要让左边的数据均小于等于轴值，右边的数据则相反；</li>
	<li>对左右两边的数据进行重复上述过程。</li>
</ul>


<strong>（3）选择排序；</strong>
<ul>
	<li>选择排序即首先纪录下第一个数值，用该数值与后面的数据一个个进行比较，保证所纪录的该数值是最小的，并记录下标；</li>
	<li>将最小的数据与第一个数据进行交换，这样做完第一个数据就保证是最小的了；</li>
	<li>从第二个数值开始，重复上述过程。</li>
</ul>


<strong>（4）堆排序；</strong>
<ul>
	<li>堆排序暂时回忆不起来了，后续待补充；</li>
	<li>堆排序暂时回忆不起来了，后续待补充；</li>
	<li>堆排序暂时回忆不起来了，后续待补充。</li>
</ul>


<strong>（5）插入排序；</strong>
<ul>
	<li>将整个数组分为局部有序区和无序区；</li>
	<li>依次将无序区的数据一个个取出来，和局部有序区的数据进行比较，并将其插入到局部有序区的合适位置；</li>
	<li>重复上述过程，直到所有的无序区的数据均插入有序区。</li>
</ul>


<strong>（6）希尔排序；</strong>
<ul>
	<li>是一种对插入排序的改进，暂时想不起来，后续有待补充</li>
	<li>是一种对插入排序的改进，暂时想不起来，后续有待补充；</li>
	<li>是一种对插入排序的改进，暂时想不起来，后续有待补充。</li>
</ul>
